<svg width="100%" height="100%" id="falling-items-svg" xmlns="http://www.w3.org/2000/svg">
    <style>
        /* Estilo para definir a cor de fundo do SVG */
        svg {
            background-color: #f0f4f0;
        }
    </style>
    <defs>
        <!-- Definição do formato da folha -->
        <g id="leaf">
            <path d="M15 0 C 10 5, 5 15, 0 20 C 5 18, 10 16, 15 15 C 20 16, 25 18, 30 20 C 25 15, 20 5, 15 0 Z"/>
        </g>
        <!-- Definição da gota, baseada no seu logo GreenDrop -->
        <g id="greendrop">
            <path d="M15 0 C -5 15, 15 35, 15 35 C 15 35, 35 15, 15 0 Z"/>
        </g>
    </defs>

    <script type="text/javascript">
    // <![CDATA[
        // Configurações da animação
        const NUM_ITEMS = 60;
        const COLORS = ["#4CAF50", "#8BC34A", "#388E3C", "#66BB6A", "#A5D6A7"]; // Tons de verde

        const svgNS = "http://www.w3.org/2000/svg";
        // O container é o próprio elemento SVG raiz
        const svgContainer = document.getElementById("falling-items-svg");
        
        let fallingItems = [];

        // Função para obter as dimensões da viewport
        function getViewportSize() {
            // Usa as dimensões do container SVG
            return {
                width: svgContainer.clientWidth,
                height: svgContainer.clientHeight
            };
        }

        // Função para criar um item (folha ou gota)
        function createFallingItem() {
            const viewport = getViewportSize();
            // Decide aleatoriamente se cria uma folha ou uma gota (70% folha, 30% gota)
            const isLeaf = Math.random() > 0.3; 
            const shapeId = isLeaf ? "#leaf" : "#greendrop";

            const useEl = document.createElementNS(svgNS, "use");
            useEl.setAttribute("href", shapeId);
            
            const item = {
                el: useEl,
                x: Math.random() * viewport.width,
                y: -100 - Math.random() * viewport.height,
                scale: 0.4 + Math.random() * 0.5,
                color: COLORS[Math.floor(Math.random() * COLORS.length)],
                fallSpeed: 1 + Math.random() * 2,
                sway: {
                    amplitude: 20 + Math.random() * 40,
                    speed: 0.01 + Math.random() * 0.02,
                    offset: Math.random() * 100
                },
                rotation: {
                    angle: Math.random() * 360,
                    speed: -2 + Math.random() * 4
                }
            };
            
            // Aplica os atributos iniciais
            item.el.setAttribute("fill", item.color);
            item.el.setAttribute("transform", `translate(${item.x}, ${item.y}) scale(${item.scale}) rotate(${item.rotation.angle})`);
            
            svgContainer.appendChild(item.el);
            return item;
        }

        // Criar os itens iniciais
        for (let i = 0; i < NUM_ITEMS; i++) {
            fallingItems.push(createFallingItem());
        }

        // Função principal da animação
        function animate() {
            const viewport = getViewportSize();

            fallingItems.forEach(item => {
                // 1. Atualizar a posição vertical (queda)
                item.y += item.fallSpeed;

                // 2. Atualizar o balanço horizontal (sway)
                item.sway.offset += item.sway.speed;
                const swayX = Math.sin(item.sway.offset) * item.sway.amplitude;

                // 3. Atualizar a rotação
                item.rotation.angle += item.rotation.speed;
                
                // 4. Aplicar a transformação no elemento SVG
                item.el.setAttribute("transform", `translate(${item.x + swayX}, ${item.y}) scale(${item.scale}) rotate(${item.rotation.angle})`);

                // 5. Se o item sair da tela, reseta sua posição no topo
                if (item.y > viewport.height + 100) {
                    item.y = -100; // Começa um pouco acima da tela
                    item.x = Math.random() * viewport.width;
                }
            });

            // Chama o próximo quadro da animação
            requestAnimationFrame(animate);
        }

        // Inicia a animação quando o SVG for carregado
        animate();
    // ]]>
    </script>
</svg>
